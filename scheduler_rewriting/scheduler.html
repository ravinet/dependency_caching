    // have a 'pending' queue per origin and also number of requests in flight
    pending_queues = {};
    in_flight = {};

    for ( var ii = 0; ii < chunked_html.length; ii++ ) {
         if ( chunked_html[ii].indexOf("<\\/script>") != -1 ) {
            chunked_html[ii] = "</sc" + "ript>";
         }
    }

    cleared_document = false;

    // urls which we have already evaluated
    evaluated = [];

    console.log("IN THE SCHEDULER");

    // requests which we have not yet evaluated because parent was not yet evaluated
    to_evaluate = [];

    // global callback function for requests
    xhr_callback = function () {
        // decrement the in_flight counter
        in_flight[this.original_origin] = in_flight[this.original_origin] - 1;

        // check the pending queue for this origin and make the next best request (as many as possible)!
        var ret = best_request( this.original_origin );
        console.log( "response back for: " + this.requested_url + " status outstanding: " + in_flight[this.original_origin] );
        while ( ret[0] ) {
            console.log("Returned response for: " + this.requested_url + " now making: " + ret[1].requested_url );
            _xhrsend.call(ret[1]);
            in_flight[ret[1].original_origin] = in_flight[ret[1].original_origin] + 1;
            ret = best_request( this.original_origin );
        }

        handle_to_eval();

        if ( can_eval(this) ) { // we can eval it now!
            evaluate_response(this);
        } else { // we cant eval it now
            to_evaluate.push(this);
        }
    };

    var _xhrsend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(){
        // assign new callback while preserving original
        this.onload_orig = this.onload;
        this.onload = xhr_callback;

        // if the request is synchronous, make it right away, update in-flight vals, and exit
        if ( this.async == false ) {
            _xhrsend.call(this);
            in_flight[this.original_origin] = in_flight[this.original_origin] + 1;
            return;
        }

        // always add incoming request to pending for the right origin
        if ( this.original_origin in pending_queues ) {
            pending_queues[this.original_origin].push(this);
        } else {
            pending_queues[this.original_origin] = [this];
        }

        if ( !(this.original_origin in in_flight) ) {
            in_flight[this.original_origin] = 0;
        }

        // find the best request for this origin and make it if we can make one now, until we can't make one
        var ret = best_request( this.original_origin );
        console.log( "Incoming request is: " + this.requested_url + " Make status: " + in_flight[this.original_origin] );
        while ( ret[0] ) {
            console.log( "Incoming request is: " + this.requested_url + " Made: " + ret[1].requested_url );
            _xhrsend.call(ret[1]);
            in_flight[ret[1].original_origin] = in_flight[ret[1].original_origin] + 1;
            ret = best_request( this.original_origin );
        }
    };

    var _xhropen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url, async, user, password){
        // handle optional arguments
        var async_use = async;
        var user_use = user;
        var password_use = password;
        if ( async == undefined ) {
            async_use = true;
        }
        if ( user == undefined ) {
            user_use = "";
        }
        if ( password == undefined ) {
            password_use = "";
        }

        // check if URL info was added to request...if not, add it
        if ( !this.hasOwnProperty("original_origin") ) {
            this.original_origin = window.location.hostname;
            this.requested_url = url;
        }

        // check if request is synchronous
        if ( async == false ) {
            this._async = false;
        } else {
            this._async = true;
        }

        var retVal = _xhropen.call(this, method, url, async_use, user_use, password_use);
        return retVal;
    };

    // prefetch is dict where keys are origins and values are arrays...values are arrays of arrays where each array is url and the corresponding id
    for ( var y = 0; y < Object.keys(prefetch).length; y++ ) {
        // handle this origin (if more than 6, consider depth)!
        curr_origin = Object.keys(prefetch)[y];
        if ( curr_origin == "use_location" ) {
            curr_origin = window.location.hostname;
        }
        reqs_to_make = prefetch[Object.keys(prefetch)[y]]; // array of arrays where each inner array is url, id
        for ( var i = 0; i < reqs_to_make.length; i++ ) {
            //console.log("handling request: " + reqs_to_make[i][0]);
            // make xhr request for each (and add origin attirbute as location.hostname) and then send it
            var req = new XMLHttpRequest();
            req.original_origin = curr_origin;
            req.requested_url = reqs_to_make[i][0];
            req.src_tag = reqs_to_make[i][1];
            req.open("GET", reqs_to_make[i][0], "true");
            if ( req.src_tag != "null" ) { // image so make blob request
                req.responseType = "blob";
            }
            req.send();
        }
    }

    // assign id to scheduler so we can remove it after the page is loaded
    document.currentScript.setAttribute("id", "scheduler");
    
    // function to evaluate a response
    function evaluate_response(req) {
        // if request has an imageid, re-assign the source
        if ( req.hasOwnProperty("src_tag") ) {
            if ( req.src_tag != "null" ) {
                var imgurl = window.URL.createObjectURL(req.response);
                document.querySelector("[imgid=\"" + req.src_tag + "\"]").setAttribute("src", imgurl);
                document.querySelector("[imgid=\"" + req.src_tag + "\"]").removeAttribute("imgid");
            } else {
                // javascript so eval it right away
                window.eval(req.responseText);
            }
        } else {
            // from original JS so just execute default callback
            req.onload_orig();
        }
    
        // add url to evaluated list
        evaluated.push(validURL(req));
    }
    
    // function which recursively handles all to_eval requests based on what urls have already been evaluated
    function handle_to_eval () {
        eval_index = [];
        for ( var q = 0; q < to_evaluate.length; q++ ) {
            if ( can_eval(to_evaluate[q]) ) {
                evaluate_response(to_evaluate[q]);
                eval_index.push(q);
            }
        }
    
        // remove all evaluated responses from the to_evaluate queue
        first = true;
        for ( var i = 0; i < eval_index.length; i++) {
            if ( first) {
                to_evaluate.splice(eval_index[i],1);
                first = false;
            } else {
                to_evaluate.splice(eval_index[i]-1, 1);
            }
        }
    };
    
    // function that returns array stating whether it is a chunk, begin line and end line
    function is_chunk (url) {
    // format of a chunk: /---10:40
        if ( url.indexOf("---") != -1 ) {
            // this is a chunk
            chunk = url.split("---");
            lines = chunk[1].split(":");
            return [true, lines[0], lines[1]];
        }

        // handle case where no chunks but it is html!
        if ( url == "/" ) {
            return [true, 0, 'all'];
        }
        // handle case where it is not chunk but it is an iframe (not "/")
        if ( url.substr(url.length - 4) == "html" ) {
            return [true, 0, 'all'];
        }

        // not a chunk!
        return [false, 0, 0];
    }

    // function which checks if we can evaluate a specific response now
    function can_eval (req) {
        var curr_url = validURL(req);
        var can_eval_req = true;
        for ( var j = 0; j < scheduler_parents[curr_url].length; j++ ) {
            parent_url = scheduler_parents[curr_url][j];
            if ( evaluated.indexOf(parent_url) == -1 ) {
                ret = is_chunk(parent_url);
                if ( ret[0] ) {
                    can_eval_parent = true;
                    // this is a chunk so check if we can eval it and if so, do it
                    for ( var q = 0; q < scheduler_parents[parent_url]; q++ ) {
                        parent_parent = scheduler_parents[parent_url][q];
                        if ( evaluated.indexOf(parent_parent) == -1 ) {
                            can_eval_parent = false;
                        }
                    }
                    if ( can_eval_parent ) {
                        // document.write chunk and add to evaled
                        if ( ret[2] == 'all' ) {
                            console.log( "wrote to document");
                            var prev_inner = "null";
                            if ( document.body != null ) {
                                prev_inner = document.body.innerHTML;
                            }
                            new_inner = window.chunked_html.join("");
                            if ( prev_inner != "null" ) {
                                new_inner = prev_inner + window.chunked_html.join("");
                            }
                            document.body.innerHTML = new_inner;
                        } else {
                            var html_to_eval = window.chunked_html.slice(ret[1]-1, ret[2]).join("");
                            var prev_inner = "null";
                            if ( document.body != null ) {
                                prev_inner = document.body.innerHTML;
                            }
                            if ( prev_inner != "null" ) {
                                html_to_eval = prev_inner + window.chunked_html.slice(ret[1]-1, ret[2]).join("");
                            }

                            document.body.innerHTML = html_to_eval;
                        }
                        evaluated.push(parent_url);
                    } else {
                        // chunk can't be evaled
                        return false;
                    }
                } else {
                    // not a chunk so we can't be evaled yet!
                    return false;
                }
            }
        }

        // we can evaluate it now!
        return true;
    }
    
    // function that decides whether or not to make a request based on the tree, pending lists, etc.
    function best_request(origin) {
        var best_req = "null";
        var best_req_index = "null";
        var curr_depth = -1;
        // find request if we have open connections
        if ( in_flight[origin] < 6 ) {
            // find the request with the longest chain remaining
            for ( var i = 0; i < pending_queues[origin].length; i++ ) {
                var curr = pending_queues[origin][i];
                if ( scheduler_depths[validURL(curr)] > curr_depth ) {
                    curr_depth = scheduler_depths[validURL(curr)];
                    best_req_index = i;
                    best_req = curr;
                }
            }
        }
    
        if ( best_req != "null" ) {
            // we have a request to send so remove from pending
            pending_queues[origin].splice(best_req_index, 1);
            return [true, best_req];
        }
    
        // we can't send anything!
        return [false, "null"];
    }
    
    // given request, function returns the corresponding complete url
    function validURL(req) {
        var url = req.requested_url;
    
        // check if it is valid---probably need a better way
        var top_domains = [".com", ".org", ".net", ".int", ".edu", ".gov", ".mil"];
        for ( var y = 0; y < top_domains.length; y++ ) {
            curr_domain = top_domains[y];
            if ( url.indexOf(curr_domain) > -1 ) {
                // contains a valid top-level domain so assume it is a url, not filename
                return url;
            }
        }
    
        // url did not have top level domain so assume file and add domain
        //if ( url.charAt(0) == '/' ) {
        //    // starts with / so likely request to same domain as original scope
        //    url = "http://" + req.original_origin + url;
        //} else {
        //    url = "http://" + req.original_origin + "/" + url;
        //}
    
        return url;
    }

    // remove scheduler immediately after defining callbacks/wrappers and making prefetch requests
    var t = document.getElementById("scheduler");
    t.parentNode.removeChild(t);
</script>
