    // have a 'pending' queue per origin and also number of requests in flight
    pending_queues = {};
    in_flight = {"bootstrap": "waiting"};

    // if top-frame, we don't need to bootstrap
    if ( window.top == window.self ) {
        in_flight["bootstrap"] = "done";
    }

    for ( var ii = 0; ii < chunked_html.length; ii++ ) {
         if ( chunked_html[ii].indexOf("<\\/script>") != -1 ) {
            chunked_html[ii] = "</sc" + "ript>";
         }
    }

    // urls which we have already evaluated
    evaluated = [];

    // html currently being evaluated
    curr_html_eval = [];

    // last html added
    last_added = -1;

    console.log("IN THE SCHEDULER");

    // requests which we have not yet evaluated because parent was not yet evaluated
    to_evaluate = [];

    // global callback function for requests
    xhr_callback = function () {
        // decrement the in_flight counter
        in_flight[this.original_origin] = in_flight[this.original_origin] - 1;
        update_in_flight(this.original_origin, in_flight[this.original_origin]);

        // check the pending queue for this origin and make the next best request (as many as possible)!
        var ret = best_request( this.original_origin );
        while ( ret[0] ) {
            _xhrsend.call(ret[1]);
            in_flight[ret[1].original_origin] = in_flight[ret[1].original_origin] + 1;
            update_in_flight(ret[1].original_origin, in_flight[ret[1].original_origin]);
            ret = best_request( this.original_origin );
        }

        handle_to_eval();

        if ( can_eval(this) ) { // we can eval it now!
            evaluate_response(this);
        } else { // we cant eval it now
            to_evaluate.push(this);
        }

        // check to see if we can eval any other chunks! (don't for now because how do we know if chunk is from this frame??)
        //handle_all_chunks();
    };

    // iterates through all nodes--if parents are all done and it is not evaluated, eval it (only chunks)---assume start of chunk same as parent (should be same frame!)
    function handle_all_chunks(parent_evaled) {
        for ( node in scheduler_depths ) {
            if ( !(in_array(evaluated, node, "exact")) ) { // node not yet evaled!
                var ret = is_chunk(node);
                var can_eval_node = true;
                if ( ret[0] ) { //it's a chunk!
                    if ( (node.split("---")[0] == parent_evaled.split("---")[0]) || (parent_evaled.indexOf("---") == -1) ) { // same html file name or parent not a chunk
                        var rel_key = best_key(scheduler_parents, node, "exact" );
                        if ( rel_key == "null" ) {
                            rel_key = best_key(scheduler_parents, node);
                        }
                        if ( scheduler_parents[rel_key].indexOf(parent_evaled) != -1 ) {
                            for ( var q = 0; q < scheduler_parents[rel_key].length; q++ ) {
                                var parent_parent = scheduler_parents[rel_key][q];
                                if ( !(in_array(evaluated, parent_parent, "exact")) ) {
                                    can_eval_node = false;
                                }
                            }
                            if ( can_eval_node ) {
                                if ( document.body == null ) {
                                    var x = document.createElement("body");
                                    document.firstChild.appendChild(x);
                                }
                                if ( ret[2] == 'all' ) {
                                    var pret = add_html(0, "end");
                                    if ( pret == false ) {
                                        return;
                                    }
                                } else {
                                    evaluated.push(node);
                                    var pret = add_html(ret[1], ret[2]);
                                    if ( pret == false ) {
                                        return;
                                    }
                                }
                                evaluated.push(node);
                                notify_eval();
                                handle_all_chunks(node);
                                handle_to_eval();
                            }
                        }
                    }
                }
            }
        }
    }

    var _xhrsend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(){
        // assign new callback while preserving original
        this.onload_orig = this.onload;
        this.onload = xhr_callback;

        // if the request is synchronous, make it right away, update in-flight vals, and exit
        if ( this.async == false ) {
            _xhrsend.call(this);
            in_flight[this.original_origin] = in_flight[this.original_origin] + 1;
            update_in_flight(this.original_origin, in_flight[this.original_origin]);
            return;
        }

        // always add incoming request to pending for the right origin
        if ( this.original_origin in pending_queues ) {
            pending_queues[this.original_origin].push(this);
        } else {
            pending_queues[this.original_origin] = [this];
        }

        // ensure that requested url is in depth/parent info
        check_graph(this);

        if ( best_key(in_flight, this.original_origin, "exact" ) == "null" ) {
            in_flight[this.original_origin] = 0;
            update_in_flight(this.original_origin, 0);
        }

        // find the best request for this origin and make it if we can make one now, until we can't make one
        var ret = best_request( this.original_origin );
        while ( ret[0] ) {
            _xhrsend.call(ret[1]);
            in_flight[ret[1].original_origin] = in_flight[ret[1].original_origin] + 1;
            update_in_flight(ret[1].original_origin, in_flight[ret[1].original_origin]);
            ret = best_request( this.original_origin );
        }
    };

    var _xhropen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url, async, user, password){
        // handle optional arguments
        var async_use = async;
        var user_use = user;
        var password_use = password;
        if ( async == undefined ) {
            async_use = true;
        }
        if ( user == undefined ) {
            user_use = "";
        }
        if ( password == undefined ) {
            password_use = "";
        }

        // check if URL info was added to request...if not, add it
        if ( !this.hasOwnProperty("original_origin") ) {
            this.original_origin = window.location.hostname;
            this.requested_url = url;
        }

        // check if request is synchronous
        if ( async == false ) {
            this._async = false;
        } else {
            this._async = true;
        }

        var retVal = _xhropen.call(this, method, url, async_use, user_use, password_use);
        return retVal;
    };

    // function to handle postMessages (top frame handles queries, query responses, and updates while other frames handle updates
    // query is "query", query response is  and update is form "update~~origin~~new_num", query response is "queryresponse---origin::num~~..."
    function handle_posts(event) {
        // handle bootstrap
        if ( event.data == "query" ) {
            if ( window.top == window.self ) {
                // we are top frame so respond with all in_flight info (queryresponse---origin::num~~origin::num~~ etc...)
                var query_response = "queryresponse---";
                for (orig in in_flight) {
                    if ( orig != "bootstrap" ) {
                        query_response = query_response + orig + "::" + in_flight[orig] + "~~";
                    }
                }
                query_response = query_response.substring(0, query_response.length-2);
                // add eval info
                query_response = query_response + "-*-";
                for ( var u = 0; u < evaluated.length; u++ ) {
                    query_response = query_response + evaluated[u] + "#~#";
                }
                query_response = query_response.substring(0, query_response.length-3);
                event.source.postMessage(query_response, event.origin);
            }
        }

        // handle query responses
        if ( event.data.split("---")[0] == "queryresponse" ) {
            var stripped_response = event.data.split("---")[1].split("-*-")[0];
            var eval_info = event.data.split("-*-")[1];
            var mappings = stripped_response.split("~~");
            for ( var i = 0; i < mappings.length; i++ ) {
                var curr_origin = mappings[i].split("::")[0];
                var curr_num = mappings[i].split("::")[1];
                in_flight[curr_origin] = curr_num;
            }
            in_flight["bootstrap"] = "done";
            var evaled_res = eval_info.split("#~#");
            for ( var i = 0; i < evaled_res.length; i++ ) {
                if ( evaluated.indexOf(evaled_res[i]) == -1 ) {
                    evaluated.push(evaled_res[i]);
                }
            }
        }

        // handle update
        if ( event.data.split("~~")[0] == "update" ) {
            if ( in_flight["bootstrap"] == "done" ) { // only use updates if you have finished bootstrap
                var origin_to_update = event.data.split("~~")[1];
                var new_num = event.data.split("~~")[2];
                in_flight[origin_to_update] = new_num;
            }
        }

        // handle eval updates
        if ( event.data.substring(0,3) == "***" ) {
            var evaled_url = event.data.split("~~~");
            for ( var i = 1; i < evaled_url.length; i++ ) {
                if ( evaluated.indexOf(evaled_url[i]) == -1 ) {
                    evaluated.push(evaled_url[i]);
                }
            }
            evaluated.push(evaled_url);
            handle_to_eval();
        }
    }


    // event listener for in_flight bootstrap or updates
    window.addEventListener("message", handle_posts, false);

    // if this is the top frame, do everything normally, otherwise make postMessage to get inflight from top frame
    // and observe in_flight until it changes (handle prefetch and html chunks in handler)
    if ( window.top == window.self ) {
        handle_prefetch();
    } else {
        in_flight.watch( "bootstrap", watch_handler );
        window.top.postMessage( "query", "*" );
    }

    // function for watch (must return the modified value and call prefetch handler!)
    function watch_handler(id, oldval, newval) {
        handle_prefetch();
        return newval;
    }

    // function to update other frames with changed in_flight value
    function update_in_flight(origin, new_num) {
        var update_message = "update~~" + origin + "~~" + new_num;
        var frames = window.top.frames;
        for ( var i = 0; i < frames.length; i++ ) {
            if ( frames[i] != window.self ) {
                frames[i].postMessage(update_message, "*");
            }
        }
    }

    // function to update other frames about new responses that have been evaled
    function notify_eval() {
        var update_message = "***eval~~~";
        for ( var u = 0; u < evaluated.length; u++ ) {
            update_message = update_message + evaluated[u] + "~~~";
        }
        update_message = update_message.substring(0, update_message.length - 3);
        var frames = window.top.frames;
        for ( var i = 0; i < frames.length; i++ ) {
            if ( frames[i] != window.self ) {
                frames[i].postMessage(update_message, "*");
            }
        }
    }

    // prefetch is dict where keys are origins and values are arrays...values are arrays of arrays where each array is url and the corresponding id
    function handle_prefetch() {
        // make sure that we copy over "use_location" to be window.location.hostname;
        if ( "use_location" in prefetch ) {
            if ( window.location.hostname in prefetch ) {
                for ( var p = 0; p < prefetch["use_location"].length; p++ ) {
                    prefetch[window.location.hostname].push(prefetch["use_location"][p]);
                }
            } else {
                prefetch[window.location.hostname] = prefetch["use_location"];
            }
            delete prefetch["use_location"];
        }

        var chunk_is_parent = false;
        var first_chunk = "";
        // find first chunk name
        for ( node in scheduler_depths ) {
            if ( node.indexOf("---") != -1 ) {
                if ( node.split("---")[1].split(":")[0] == "0") {
                    first_chunk = node;
                }
            }
        }

        for ( var y = 0; y < Object.keys(prefetch).length; y++ ) {
            // handle this origin (if more than 6, consider depth)!
            curr_origin = Object.keys(prefetch)[y];
            reqs_to_make = prefetch[Object.keys(prefetch)[y]]; // array of arrays where each inner array is url, id
            for ( var i = 0; i < reqs_to_make.length; i++ ) {
                //console.log("handling request: " + reqs_to_make[i][0]);
                // make xhr request for each (and add origin attirbute as location.hostname) and then send it
                var req = new XMLHttpRequest();
                req.original_origin = curr_origin;
                req.requested_url = reqs_to_make[i][0];
                if ( req.requested_url.substring(0,2) == "//" ) {
                    req.requested_url = "http:" + reqs_to_make[i][0];
                }
                if ( req.requested_url.substring(0,2) == ".." ) {
                    req.requested_url = html_name + reqs_to_make[i][0].substring(3);
                }
                req.src_tag = reqs_to_make[i][1];
                req.open("GET", reqs_to_make[i][0], "true");
                if ( (reqs_to_make[i][0].indexOf(".css") != -1) || (reqs_to_make[i][0].indexOf(".ico") != -1) ) { // it is a css file (use href, not src)
                    req.is_css = true;
                } else {
                    req.is_css = false;
                }
                if ( req.src_tag != "null" ) { // image, iframe so make blob request
                    req.responseType = "blob";
                }
                req.send();
                var rel_key = best_key(scheduler_parents, req.requested_url, "exact" );
                if ( rel_key == "null" ) {
                    rel_key = best_key(scheduler_parents, req.requested_url);
                }
                if ( first_chunk in scheduler_parents[rel_key] ) {
                    chunk_is_parent = true;
                }
            }
        }

        if ( !chunk_is_parent ) {
            var ret = is_chunk(first_chunk);
            if ( ret[0] ) {
                if ( document.body == null ) {
                    var x = document.createElement("body");
                    document.firstChild.appendChild(x);
                }
                if ( ret[2] == 'all' ) {
                    var pret = add_html(0, "end");
                    if ( pret == false ) {
                        return false;
                    }
                } else {
                    var pret = add_html(ret[1], ret[2]);
                    if ( pret == false ) {
                        return false;
                    }
                }
                evaluated.push(first_chunk);
                notify_eval();
                handle_all_chunks(first_chunk);
                handle_to_eval();
            }
        }

        // handle case where there is nothing to prefetch!
        if ( Object.keys(prefetch).length == 0 ) {
            var curr_html = window.location.pathname;
            // TODO: need to get complete URL here since we match it below with other URLs (if URL, change equality below to use match_urls)
            if ( curr_html != "/" ) {
                // remove path "/"
                var split_path = curr_html.split("/");
                curr_html = split_path[split_path.length - 1];
            }
            // iterate through scheduler parents and find the smallest chunk that we can evaluate right away
            // also store the parents of any chunk for this file to make sure we actually can eval it!
            var final_chunk_start = "null";
            var final_chunk_end = "null";
            for ( var child in scheduler_parents ) {
                var parents = scheduler_parents[child];
                for ( p in parents ) {
                    var curr_parent = parents[p];
                    var file_name = curr_parent;
                    var chunk_start = "null";
                    var chunk_end = "null";
                    if ( curr_parent.indexOf("---") != -1 ) {
                        // it is a chunk!
                        file_name = curr_parent.split("---")[0];
                        chunk_start = curr_parent.split("---")[1].split(":")[0];
                        chunk_end = curr_parent.split("---")[1].split(":")[1];
                    }
                    if ( file_name == curr_html ) { // relevant parent so see if this is the best chunk
                        if ( chunk_start != "null" ) {
                            if ( (final_chunk_start == "null") || (chunk_start < final_chunk_start) ) {
                                final_chunk_start = chunk_start;
                                final_chunk_end = chunk_end;
                            }
                        }
                    }
                }
            }

            // check if there is a 'best' chunk...if not, add all html!
            var html_url;
            if ( document.body == null ) {
                var x = document.createElement("body");
                document.firstChild.appendChild(x);
            }
            if ( final_chunk_start == "null" ) { // no 'best' chunk
                html_url = file_name;
                add_html(0, "end");
                evaluated.push(html_url);
                notify_eval();
                handle_all_chunks(html_url);
            } else { // there is a best chunk
                html_url = file_name + "---" + final_chunk_start + ":" + final_chunk_end;
                add_html(final_chunk_start, final_chunk_end);
                evaluated.push(html_url);
                notify_eval();
                handle_all_chunks(html_url);
            }
        }
    }

    // assign id to scheduler so we can remove it after the page is loaded
    document.currentScript.setAttribute("id", "scheduler");
    
    // function to evaluate a response
    function evaluate_response(req) {
        // if request has an imageid, re-assign the source
        if ( req.hasOwnProperty("src_tag") ) {
            if ( req.src_tag != "null" ) {
                var imgurl = window.URL.createObjectURL(req.response);
                if ( req.is_css ) {
                    document.querySelector("[imgid=\"" + req.src_tag + "\"]").setAttribute("href", imgurl);
                    document.querySelector("[imgid=\"" + req.src_tag + "\"]").removeAttribute("imgid");
                } else {
                    var t = document.querySelector("[imgid=\"" + req.src_tag + "\"]");
                    if ( document.querySelector("[imgid=\"" + req.src_tag + "\"]").nodeName == "LINK" ) {
                        document.querySelector("[imgid=\"" + req.src_tag + "\"]").setAttribute("href", imgurl);
                        document.querySelector("[imgid=\"" + req.src_tag + "\"]").removeAttribute("imgid");
                    } else {
                        document.querySelector("[imgid=\"" + req.src_tag + "\"]").setAttribute("src", imgurl);
                        document.querySelector("[imgid=\"" + req.src_tag + "\"]").removeAttribute("imgid");
                    }
                }
            } else {
                // javascript so eval it right away
                window.eval(req.responseText);
            }
        } else {
            // from original JS so just execute default callback
            req.onload_orig();
        }
    
        // add url to evaluated list
        evaluated.push(validURL(req));

        // notify other frames that this url is evaluated
        notify_eval();

        // check if node is in to_evaluate, and if so, remove it
        var pos = to_evaluate.indexOf(req);
        if ( pos != -1 ) {
            to_evaluate.splice(pos, 1);
        }

        // check if this triggers any other chunks
        handle_all_chunks(validURL(req));
        handle_to_eval();
    }
    
    // function which recursively handles all to_eval requests based on what urls have already been evaluated
    function handle_to_eval () {
        eval_index = [];
        for ( var q = 0; q < to_evaluate.length; q++ ) {
            if ( can_eval(to_evaluate[q]) ) {
                evaluate_response(to_evaluate[q]);
                eval_index.push(q);
            }
        }
    
        //// remove all evaluated responses from the to_evaluate queue
        //first = true;
        //for ( var i = 0; i < eval_index.length; i++) {
        //    if ( first) {
        //        to_evaluate.splice(eval_index[i],1);
        //        first = false;
        //    } else {
        //        to_evaluate.splice(eval_index[i]-1, 1);
        //    }
        //}
    };
    
    // function that returns array stating whether it is a chunk, begin line and end line
    function is_chunk (url) {
    // format of a chunk: /---10:40
        if ( url.indexOf("---") != -1 ) {
            // this is a chunk
            chunk = url.split("---");
            lines = chunk[1].split(":");
            return [true, lines[0], lines[1]];
        }


        // handle case where no chunks but it is html!
        if ( url == "/" ) {
            return [true, 0, 'all'];
        }
        // handle case where it is not chunk but it is an iframe (not "/")
        if ( (url.substr(url.length - 4) == "html") || (url == window.html_name) ) {
            return [true, 0, 'all'];
        }

        // not a chunk!
        return [false, 0, 0];
    }

    // function which checks if we can evaluate a specific response now
    function can_eval (req) {
        var curr_url = validURL(req);
        var can_eval_req = true;
        var rel_key = best_key(scheduler_parents, curr_url, "exact" );
        if ( rel_key == "null" ) {
            rel_key = best_key(scheduler_parents, curr_url);
        }

        for ( var j = 0; j < scheduler_parents[rel_key].length; j++ ) {
            parent_url = scheduler_parents[rel_key][j];
            // check if parent has not yet been evaluated!
            if ( !(in_array(evaluated, parent_url, "exact")) ) {
                ret = is_chunk(parent_url);
                if ( ret[0] ) {
                    can_eval_parent = true;
                    // this is a chunk so check if we can eval it and if so, do it
                    var rel_parent_key = best_key(scheduler_parents, parent_url, "exact" );
                    if ( rel_parent_key == "null" ) {
                        rel_parent_key = best_key(scheduler_parents, parent_url);
                    }
                    for ( var q = 0; q < scheduler_parents[rel_parent_key].length; q++ ) {
                        parent_parent = scheduler_parents[rel_parent_key][q];
                        if ( !(in_array(evaluated, parent_parent, "exact")) ) {
                            can_eval_parent = false;
                        }
                    }
                    if ( can_eval_parent ) {
                        // document.write chunk and add to evaled
                        if ( document.body == null ) {
                            var x = document.createElement("body");
                            document.firstChild.appendChild(x);
                        }
                        if ( ret[2] == 'all' ) {
                            var pret = add_html(0, "end");
                            if ( pret == false ) {
                                return false;
                            }
                        } else {
                            var pret = add_html(ret[1], ret[2]);
                            if ( pret == false ) {
                                return false;
                            }
                        }
                        evaluated.push(parent_url);
                        notify_eval();
                        // handle any new chunks that we can based on this parent
                        handle_all_chunks(parent_url);
                        handle_to_eval();
                    } else {
                        // chunk can't be evaled
                        return false;
                    }
                } else {
                    // not a chunk so we can't be evaled yet!
                    return false;
                }
            }
        }

        // we can evaluate it now!
        return true;
    }
    
    // function that decides whether or not to make a request based on the tree, pending lists, etc.
    function best_request(origin) {
        var best_req = "null";
        var best_req_index = "null";
        var curr_depth = -1;
        // find request if we have open connections
        if ( in_flight[origin] < 6 ) {
            // find the request with the longest chain remaining
            for ( var i = 0; i < pending_queues[origin].length; i++ ) {
                var curr = pending_queues[origin][i];
                var rel_key = best_key(scheduler_depths, validURL(curr), "exact" );
                if ( rel_key == "null" ) {
                    rel_key = best_key(scheduler_depths, validURL(curr));
                }
                if ( scheduler_depths[rel_key] > curr_depth ) {
                    curr_depth = scheduler_depths[rel_key];
                    best_req_index = i;
                    best_req = curr;
                }
            }
        }
    
        if ( best_req != "null" ) {
            // we have a request to send so remove from pending
            pending_queues[origin].splice(best_req_index, 1);
            return [true, best_req];
        }
    
        // we can't send anything!
        return [false, "null"];
    }
    
    // given request, function returns the corresponding complete url
    function validURL(req) {
        var url = req.requested_url;
    
        // check if it is valid---probably need a better way
        var top_domains = [".com", ".org", ".net", ".int", ".edu", ".gov", ".mil"];
        for ( var y = 0; y < top_domains.length; y++ ) {
            curr_domain = top_domains[y];
            if ( url.indexOf(curr_domain) > -1 ) {
                // contains a valid top-level domain so assume it is a url, not filename
                return url;
            }
        }
    
        // url did not have top level domain so assume file and add domain
        //if ( url.charAt(0) == '/' ) {
        //    // starts with / so likely request to same domain as original scope
        //    url = "http://" + req.original_origin + url;
        //} else {
        //    url = "http://" + req.original_origin + "/" + url;
        //}
    
        return url;
    }

    // function returns the length of max common substring between args
    function max_common_substring(string1, string2){
        var longestCommonSubstring = 0;
        var table = [],
                len1 = string1.length,
                len2 = string2.length,
                row, col;
        for(row = 0; row <= len1; row++){
            table[row] = [];
            for(col = 0; col <= len2; col++){
                table[row][col] = 0;
            }
        }
        var i, j;
        for(i = 0; i < len1; i++){
            for(j = 0; j < len2; j++){
                if(string1[i]==string2[j]){
                    if(table[i][j] == 0){
                        table[i+1][j+1] = 1;
                    } else {
                        table[i+1][j+1] = table[i][j] + 1;
                    }
                    if(table[i+1][j+1] > longestCommonSubstring){
                        longestCommonSubstring = table[i+1][j+1];
                    }
                } else {
                    table[i+1][j+1] = 0;
                }
            }
        }
        return longestCommonSubstring;
    }

    // function that matches urls and returns array [true/false about whether it matches, max substring length]
    function match_urls(firsturl, secondurl) {
        var first_is_url = true;
        var second_is_url = true;
        var url1 = "";
        var url2 = "";
        try {
            url1 = new URL(firsturl);
        } catch(err) {
            first_is_url = false;
        }
        try {
            url2 = new URL(secondurl);
        } catch(err) {
            second_is_url = false;
        }

        if ( first_is_url && second_is_url ) {
            // both are URLs so check if resource name matches
            if ( url1.origin == url2.origin ) {
                if ( url1.pathname == url2.pathname ) {
                    // assume entire path must match (should we only care about object name?)
                    // find querystring max substring length
                    if ( ((url1.search == "") && (url2.search == "" )) || ((url1.search == url2.search )) ) {
                        return [true, Infinity];
                    }
                    return [true, max_common_substring(url1.search, url2.search)];
                }
            }
            return [false, 0];
        } else if ( first_is_url != second_is_url ) {
            // one is complete URL and other is not (assume match if non-url is exact substring of url)
            if ( first_is_url ) {
                if ( url1.pathname.indexOf(secondurl) != -1 ) {
                    return [true, Infinity];
                }
            } else {
                if ( url2.pathname.indexOf(firsturl) != -1 ) {
                    return [true, Infinity];
                }
            }
            // non-url is not exact substring of url!
            return [false, 0];
        } else {
            // neither is complete url so assume they are files (check if they match exactly)
            if ( firsturl == secondurl ) {
                return [true, Infinity];
            } else {
                return [false, 0];
            }
        }
    }

    // function that iterates through a specified dictionary and finds the best matching URL with the url argument (return matching key)
    function best_key(dict, url, quality="rough") {
        var possible = [];
        for ( var i = 0; i < Object.keys(dict).length; i++ ) {
            var ret = match_urls(Object.keys(dict)[i], url);
            if ( ret[0] ) {
                if ( quality == "exact" ) {
                    if ( ret[1] == Infinity ) {
                        return Object.keys(dict)[i];
                    }
                } else {
                    // there is a matching url in this dict so add to possible
                    possible.push([Object.keys(dict)[i], ret[1]]);
                }
            }
        }

        if ( possible.length == 0 ) {
            // not in dictionary!
            return "null";
        }
        // iterate through possibles and find the best match and return the value
        var best_url = "";
        var match_length = -1;
        for ( var x = 0; x < possible.length; x++ ) {
            if ( possible[x][1] > match_length ) {
                best_url = possible[x][0];
                match_length = possible[x][1];
            }
        }
        return best_url;
    }

    // function that iterates through specified array and returns bool about whether url argument is in array
    function in_array(arr, url, quality="rough") {
        for ( var j = 0; j < arr.length; j++ ) {
            var ret = match_urls(arr[j], url);
            if ( ret[0] ) {
                // some url in the array matches
                if ( quality == "exact" ) {
                    if ( ret[1] == Infinity ) {
                        return true;
                    }
                } else {
                    return true;
                }
            }
        }
        return false;
    }

    function add_html( start, end ) {
        console.log("added html from: " + start + " end: " + end);
        if ( (curr_html_eval.indexOf((start,end)) != -1 ) ) {
            return false;
        } else {
            var start_use = parseInt(start);
            var end_use = parseInt(end);
            if ( end == "end" ) {
                end_use = chunked_html.length - 1;
            }

            // if we have already added all HTML, then just return
            if ( last_added >= window.chunked_html.length-1 ) {
                return;
            }
            if ( end_use > window.chunked_html.length-1 ) {
                end_use = window.chunked_html.length-1;
                if ( start_use > end_use ) {
                    return;
                }
            }

            //var prev = document.body.innerHTML;
            var prev = "";

            var in_script = false;
            var curr_script = "";
            var unadded = "";

            var close_script = "</sc" + "ript>";

            for ( var x = start_use; x <= end_use; x++ ) {
                if ( window.chunked_html[x].indexOf("<body") != -1 ) {
                    var tag_split = window.chunked_html[x].trim().split(" ");
                    for ( var ii = 1; ii < tag_split.length; ii++ ) {
                        var attr = tag_split[ii].split("=")[0];
                        if ( tag_split[ii].indexOf("=") == -1 ) {
                            var val = tag_split[ii];
                            if ( val.slice(-1) == ">" ) {
                                val = val.substring(0, val.length-1);
                            }
                            val = val.substring(1, val.length-1);
                            document.body.setAttribute(val, "");
                        } else {
                            var val = tag_split[ii].split("=")[1];
                            if ( val.slice(-1) == ">" ) {
                                val = val.substring(0, val.length-1);
                            }
                            val = val.substring(1, val.length-1);
                            document.body.setAttribute(attr, val);
                        }
                    }
                }
                if ( window.chunked_html[x].trim() != "</body>" ) {
                    if ( window.chunked_html[x].trim().indexOf("<body") == -1 ) {
                        prev = prev + window.chunked_html[x];
                        unadded = unadded + window.chunked_html[x];
                    }
                }
                if ( chunked_html[x].trim() == "<script>" ) {
                    in_script = true;
                }
                if ( chunked_html[x].trim().indexOf( "<script type=\"text/javascript\"") != -1 ) {
                    in_script = true;
                }
                if ( in_script ) { // add line if we are in a script
                    if ( chunked_html[x].trim() == close_script ) { //add the html to innerHTML and then eval the js and clear everything
                        var last_val = document.body.innerHTML;
                        document.body.innerHTML = last_val + prev;
                        prev = "";
                        unadded = "";
                        window.eval(curr_script);
                        curr_script = "";
                        in_script = false;
                    } else {
                        if ( chunked_html[x].trim() != "<script>" ) {
                            if ( chunked_html[x].trim().indexOf("<script") == -1 ) {
                                curr_script = curr_script + window.chunked_html[x] + "\n";
                            }
                        }
                    }
                }
            }
            // add unadded content
            var last_prev = document.body.innerHTML;
            document.body.innerHTML = last_prev + unadded;
            window.last_added = end_use;
            // remove the html from list of html currently being evaluated
            for ( var x = 0; x < curr_html_eval.length; x++ ) {
                if ( curr_html_eval[x] == (start, end) ) {
                    curr_html_eval.splice(x,1);
                }
            }
        }
        console.log("finished adding html");
        return true;
    }

    function check_graph (req) {
        var curr_url = req.requested_url;
        // check scheduler_depths: if not there, add depth (js-2, css-1, html-2, img-0)
        var rel_key = best_key(scheduler_depths, curr_url);
        if ( rel_key == "null" ) {
            if ( (curr_url.indexOf(".jpg") != -1 ) || (curr_url.indexOf(".jpeg") != -1 ) || (curr_url.indexOf(".png") != -1 ) ||
               (curr_url.indexOf(".pdf") != -1 ) || (curr_url.indexOf(".gif") != -1 )) {
                scheduler_depths[curr_url] = 0;
            } else if ( (curr_url.indexOf(".js") != -1 ) ) {
                scheduler_depths[curr_url] = 2;
            } else if ( (curr_url.indexOf(".html") != -1 ) ) {
                scheduler_depths[curr_url] = 2;
            } else if ( (curr_url.indexOf(".css") != -1 ) ) {
                scheduler_depths[curr_url] = 1;
            } else { // default fallback of 1
                scheduler_depths[curr_url] = 1;
            }
        }

        // check parent list and if not there, check if the url is to be prefetched...if not then set parent to ""
        // if yes, then set parents to be all other nodes listed in depths for that same origin
        var rel_key = best_key(scheduler_parents, curr_url, "exact");
        if ( rel_key == "null" ) {
            var rel_key = best_key(scheduler_parents, curr_url);
        }
        var prefetched = false;
        var origin_key = best_key(prefetch, req.original_origin, "exact");
        if ( rel_key == "null" ) {
            if ( origin_key != "null" ) { // origin in prefetch!
                reqs_to_make = prefetch[origin_key]; // array of arrays where each inner array is url, id
                for ( var i = 0; i < reqs_to_make.length; i++ ) {
                    if ( match_urls(reqs_to_make[i][0], curr_url)[0] ) { // urls match
                        prefetched = true;
                    }
                }
            }
            if ( prefetched ) { // set parents to be the last chunk of the current HTML (since it is where we got prefetch from!)
                // go through scheduler_parents to get the last chunk name (html name is html_name)
                var last_chunk = "null";
                for ( var x = 0; x < Object.keys(scheduler_parents).length; x++ ) {
                    var curr_key = Object.keys(scheduler_parents)[x];
                    if ( curr_key.substring(0, html_name.length) == html_name ) { //relevant child!
                        if ( curr_key.indexOf("---") != -1 ) { // it is a chunk!
                            if ( curr_key.substring(curr_key.length - 3) == "end" ) { // last chunk!
                                last_chunk = curr_key;
                            }
                        }
                    }
                }
                if ( last_chunk == "null" ) {
                    scheduler_parents[curr_url] = [html_name];
                } else {
                    scheduler_parents[curr_url] = [last_chunk];
                }
            } else {
                scheduler_parents[curr_url] = [];
            }
        }
    }

    // remove scheduler immediately after defining callbacks/wrappers and making prefetch requests
    var t = document.getElementById("scheduler");
    t.parentNode.removeChild(t);
</script>
